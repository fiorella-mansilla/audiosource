import { S3Client, CreateMultipartUploadCommand, UploadPartCommand, CompleteMultipartUploadCommand, AbortMultipartUploadCommand } from '@aws-sdk/client-s3';
import axios from 'axios';
import config from '../config';

const apiClient = axios.create({
    baseURL: config.API_BASE_URL,
});

/**
 * Retrieves a pre-signed URL generated by the backend for uploading a file to S3.
 * @param {Object} params - Parameters for generating the signed URL (key, content_type).
 * @returns {Promise<Object>} - Object containing the signed URL.
 */
export async function getSignedUrl({ key, content_type }) {
    try {
      const response = await apiClient.post("/s3/upload/signed_url", {
        key,
        content_type,
      });
      return response.data;
    } catch (error) {
      console.error("Error getting signed URL:", error);
      throw error; 
    }
  }

  /* Uploads a file to S3 using a pre-signed URL, with support for multipart upload for large files. */
  export async function uploadFileToS3SignedUrl(key, signedUrl, file, contentType, onProgress, onComplete) {
    const s3Client = new S3Client({ 
        region: config.AWS.Region,
        credentials: {
            accessKeyId: config.AWS.AccessKeyId,
            secretAccessKey: config.AWS.AWSSecretKey,
        },
    });

    const bucketName = config.AWS.BucketName;
    
    try {
        if (file.size <= 100 * 1024 * 1024) { // Small file threshold: 100MB
            
          // Direct upload for small files
          const response = await axios.put(signedUrl, file, {
              onUploadProgress: onProgress,
              headers: {
                "Content-Type": contentType,
              },
          });
          onComplete(response);
      } else {

        // Multipart upload for large files
        let uploadId;

        try {
            // Initialize multipart upload
            const multipartUpload = await s3Client.send(new CreateMultipartUploadCommand({
                Bucket: bucketName,
                Key: key,
                ContentType: contentType,
            }));

            uploadId = multipartUpload.UploadId;

            const partSize = 5 * 1024 * 1024; // 5MB parts
            const numParts = Math.ceil(file.size / partSize);
            const uploadPromises = [];

            for (let i = 0; i < numParts; i++) {
                const start = i * partSize;
                const end = Math.min(start + partSize, file.size);
                const part = file.slice(start, end);

                const partNumber = i + 1;
                const uploadPartCommand = new UploadPartCommand({
                    Bucket: bucketName,
                    Key: key,
                    UploadId: uploadId,
                    PartNumber: partNumber,
                    Body: part,
                });

                // Upload each part and track progress
                const uploadPromise = s3Client.send(uploadPartCommand)
                    .then((data) => ({
                        ETag: data.ETag,
                        PartNumber: partNumber,
                    }));
                uploadPromises.push(uploadPromise);
            }

            // Wait for all parts to upload
            const partsData = await Promise.all(uploadPromises);

            // Complete multipart upload
            await s3Client.send(new CompleteMultipartUploadCommand({
                Bucket: bucketName,
                Key: key,
                UploadId: uploadId,
                MultipartUpload: {
                    Parts: partsData,
                },
            }));

            onComplete({ status: 'File uploaded successfully' });
        } catch (err) {
            console.error('Error uploading file: ', err);

            // Abort multupart upload if an error occurs
            if (uploadId) {
                await s3Client.send(new AbortMultipartUploadCommand({
                    Bucket: bucketName,
                    Key: key,
                    UploadId: uploadId,
                }));
            }
        
            throw err; // Rethrow the error to handle it in the caller
        }
    }
  } catch (error) {
      console.error("Error uploading file:", error);
      throw error;
  }
}